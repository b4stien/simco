{"version":3,"sources":["webpack:///309a186922b6dc66ba98.worker.js","webpack:///webpack/bootstrap 309a186922b6dc66ba98","webpack:///./worker.js"],"names":["modules","__webpack_require__","moduleId","installedModules","e","module","i","l","call","m","c","p","s","exports","_toConsumableArray","arr","Array","isArray","arr2","length","from","label","contains","String","onmessage","_e$data","data","TRIM","MAX_LENGTH","PEOPLE_IN_CAR","ITERATIONS","people","uniqueRides","tmpFreqs","Math","floor","fill","map","draws","random","tmp","shared","draw","undefined","frequencies","freq","shiftStart","threshold","max","apply","splice","reverse","cutEnd","centerGroupSize","borderGroupSize","ceil","finalLength","centerGroupNumber","borderGroupNumber","borderGroupBeforeCenter","workedFrequencies","newIndex","fakeI","_fakeI","push","formattedFrequencies","wf","postMessage"],"mappings":"CAAS,SAAUA,GCInB,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAE,CAGA,IAAAC,GAAAF,EAAAD,IACAE,KACAE,EAAAJ,EACAK,GAAA,EAUA,OANAP,GAAAE,GAAAM,KAAAH,EAAAD,EAAAC,IAAAD,EAAAH,GAGAI,EAAAE,GAAA,EAGAF,EAAAD,EAvBA,GAAAD,KAqCA,OATAF,GAAAQ,EAAAT,EAGAC,EAAAS,EAAAP,EAGAF,EAAAU,EAAA,QAGAV,IAAAW,EAAA,KDMM,SAASP,EAAQQ,GAEtB,YAEA,SAASC,GAAmBC,GAAO,GAAIC,MAAMC,QAAQF,GAAM,CAAE,IAAK,GAAIT,GAAI,EAAGY,EAAOF,MAAMD,EAAII,QAASb,EAAIS,EAAII,OAAQb,IAAOY,EAAKZ,GAAKS,EAAIT,EAAM,OAAOY,GAAe,MAAOF,OAAMI,KAAKL,GEhD3L,QAASM,GAAMC,GACX,MAAuB,KAApBA,EAASH,OACDI,OAAOD,EAAS,IAGjBA,EAAS,GAAT,IAAeA,EAASA,EAASH,OAAS,GAIxDK,UAAY,SAASpB,GFkDhB,GAAIqB,GEjDsErB,EAAEsB,KAAvEC,EAAAF,EAAAE,KAAMC,EAAAH,EAAAG,WAAYC,EAAAJ,EAAAI,cAAeC,EAAAL,EAAAK,WAAYC,EAAAN,EAAAM,OAAQC,EAAAP,EAAAO,YAEvDC,EAAWjB,MAAMkB,KAAKC,MAAMJ,EAAOF,GAAiB,GAAGO,OAAOC,IAAI,WFyDjE,MEzDwE,IAE7ErB,OAAMc,GAAYM,OAAOC,IAAI,WACzB,GAAIC,GAAQtB,MAAMe,GAAQK,OAAOC,IAAI,WF2DhC,ME3DuCH,MAAKC,MAAMD,KAAKK,SAASP,GAAe,IAChFQ,KACAC,EAAS,CAEbH,GAAMD,IAAI,SAACK,GACUC,SAAdH,EAAIE,GACHF,EAAIE,GAAQ,EAGZF,EAAIE,KAGLF,EAAIE,KAAUb,IACbY,IACAD,EAAIE,GAAQ,KAIpBT,EAASQ,MAGb,IAAIG,GAAcX,EAASI,IAAI,SAACQ,GF4D3B,ME5DqCA,GAAOf,IAC7CgB,EAAa,CACjB,IAAGnB,EAAM,CAEL,IADA,GAAMoB,GAAYb,KAAKc,IAALC,MAAAf,KAAApB,EAAY8B,IAAe,GACvCA,EAAYE,GAAcC,GAC5BD,GAEJF,GAAYM,OAAO,EAAGJ,GAEtBF,EAAYO,SAGZ,KADA,GAAIC,GAAS,EACPR,EAAYQ,GAAUL,GACxBK,GAEJR,GAAYM,OAAO,EAAGE,GAEtBR,EAAYO,UAGhB,GAAME,GAAkBnB,KAAKC,MAAMS,EAAYzB,OAASS,IAAe,EACjE0B,EAAkBpB,KAAKqB,KAAKX,EAAYzB,OAASS,GAEnD4B,EAAA,OACAC,EAAA,OACAC,EAAA,MACDd,GAAYzB,QAAUS,GACrB4B,EAAcZ,EAAYzB,OAC1BsC,EAAoBb,EAAYzB,OAChCuC,EAAoB,IAGpBF,EAAc5B,EACd6B,EAAoB7B,EAAcgB,EAAYzB,OAASS,EACvD8B,EAAoB9B,EAAa6B,EAGrC,IAAIE,GAA0BzB,KAAKqB,KAAKG,EAAoB,GAExDE,EAAoB5C,MAAMwC,GAAapB,MAC3CQ,GAAYP,IAAI,SAACQ,EAAMvC,GACnB,GAAIuD,GAAA,MACJ,IAAQF,EAAwBL,EAA7BhD,EACCuD,EAAW3B,KAAKC,MAAM7B,EAAIgD,OAEzB,IAAGhD,GAAMqD,EAAwBL,EAAkBG,EAAkBJ,EAAkB,CACxF,GAAIS,GAAQxD,GAAKqD,EAAwBL,EAAkBG,EAAkBJ,EAC7EQ,GAAWF,EAA0BF,EAAoBvB,KAAKC,MAAM2B,EAAQR,OAE3E,CACD,GAAIS,GAAQzD,EAAIqD,EAAwBL,CACxCO,GAAWF,EAA0BzB,KAAKC,MAAM4B,EAAQV,GAGzBV,SAAhCiB,EAAkBC,KACjBD,EAAkBC,IACdhB,KAAM,EACNvB,cAIRsC,EAAkBC,GAAUhB,MAAQA,EACpCe,EAAkBC,GAAUvC,SAAS0C,KAAK1D,EAAEwC,IAGhD,IAAMmB,GAAuBL,EAAkBvB,IAAI,SAAC6B,GF2D/C,OE3DwD7C,MAAOA,EAAM6C,EAAG5C,UAAWuB,KAAMqB,EAAGrB,OACjGsB,cAAcF","file":"309a186922b6dc66ba98.worker.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].e;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\te: {},\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.e, module, module.e, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.e;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"dist/\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(__webpack_require__.s = 0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction label(contains) {\n\t    if (contains.length === 1) {\n\t        return String(contains[0]);\n\t    }\n\t\n\t    return contains[0] + \"-\" + contains[contains.length - 1];\n\t}\n\t\n\tonmessage = function onmessage(e) {\n\t    var _e$data = e.data;\n\t    var TRIM = _e$data.TRIM;\n\t    var MAX_LENGTH = _e$data.MAX_LENGTH;\n\t    var PEOPLE_IN_CAR = _e$data.PEOPLE_IN_CAR;\n\t    var ITERATIONS = _e$data.ITERATIONS;\n\t    var people = _e$data.people;\n\t    var uniqueRides = _e$data.uniqueRides;\n\t\n\t\n\t    var tmpFreqs = Array(Math.floor(people / PEOPLE_IN_CAR) + 1).fill().map(function () {\n\t        return 0;\n\t    });\n\t\n\t    Array(ITERATIONS).fill().map(function () {\n\t        var draws = Array(people).fill().map(function () {\n\t            return Math.floor(Math.random() * uniqueRides) + 1;\n\t        });\n\t        var tmp = {};\n\t        var shared = 0;\n\t\n\t        draws.map(function (draw) {\n\t            if (tmp[draw] === undefined) {\n\t                tmp[draw] = 1;\n\t            } else {\n\t                tmp[draw]++;\n\t            }\n\t\n\t            if (tmp[draw] === PEOPLE_IN_CAR) {\n\t                shared++;\n\t                tmp[draw] = 0;\n\t            }\n\t        });\n\t\n\t        tmpFreqs[shared]++;\n\t    });\n\t\n\t    var frequencies = tmpFreqs.map(function (freq) {\n\t        return freq / ITERATIONS;\n\t    });\n\t    var shiftStart = 0;\n\t    if (TRIM) {\n\t        var threshold = Math.max.apply(Math, _toConsumableArray(frequencies)) / 50;\n\t        while (frequencies[shiftStart] < threshold) {\n\t            shiftStart++;\n\t        }\n\t        frequencies.splice(0, shiftStart);\n\t\n\t        frequencies.reverse();\n\t\n\t        var cutEnd = 0;\n\t        while (frequencies[cutEnd] < threshold) {\n\t            cutEnd++;\n\t        }\n\t        frequencies.splice(0, cutEnd);\n\t\n\t        frequencies.reverse();\n\t    }\n\t\n\t    var centerGroupSize = Math.floor(frequencies.length / MAX_LENGTH) || 1;\n\t    var borderGroupSize = Math.ceil(frequencies.length / MAX_LENGTH);\n\t\n\t    var finalLength = void 0;\n\t    var centerGroupNumber = void 0;\n\t    var borderGroupNumber = void 0;\n\t    if (frequencies.length <= MAX_LENGTH) {\n\t        finalLength = frequencies.length;\n\t        centerGroupNumber = frequencies.length;\n\t        borderGroupNumber = 0;\n\t    } else {\n\t        finalLength = MAX_LENGTH;\n\t        centerGroupNumber = MAX_LENGTH - frequencies.length % MAX_LENGTH;\n\t        borderGroupNumber = MAX_LENGTH - centerGroupNumber;\n\t    }\n\t\n\t    var borderGroupBeforeCenter = Math.ceil(borderGroupNumber / 2);\n\t\n\t    var workedFrequencies = Array(finalLength).fill();\n\t    frequencies.map(function (freq, i) {\n\t        var newIndex = void 0;\n\t        if (i < borderGroupBeforeCenter * borderGroupSize) {\n\t            newIndex = Math.floor(i / borderGroupSize);\n\t        } else if (i >= borderGroupBeforeCenter * borderGroupSize + centerGroupNumber * centerGroupSize) {\n\t            var fakeI = i - (borderGroupBeforeCenter * borderGroupSize + centerGroupNumber * centerGroupSize);\n\t            newIndex = borderGroupBeforeCenter + centerGroupNumber + Math.floor(fakeI / borderGroupSize);\n\t        } else {\n\t            var _fakeI = i - borderGroupBeforeCenter * borderGroupSize;\n\t            newIndex = borderGroupBeforeCenter + Math.floor(_fakeI / centerGroupSize);\n\t        }\n\t\n\t        if (workedFrequencies[newIndex] === undefined) {\n\t            workedFrequencies[newIndex] = {\n\t                freq: 0,\n\t                contains: []\n\t            };\n\t        }\n\t\n\t        workedFrequencies[newIndex].freq += freq;\n\t        workedFrequencies[newIndex].contains.push(i + shiftStart);\n\t    });\n\t\n\t    var formattedFrequencies = workedFrequencies.map(function (wf) {\n\t        return { label: label(wf.contains), freq: wf.freq };\n\t    });\n\t    postMessage({ formattedFrequencies: formattedFrequencies });\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** 309a186922b6dc66ba98.worker.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].e;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\te: {},\n \t\t\ti: moduleId,\n \t\t\tl: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.e, module, module.e, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.e;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"dist/\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 309a186922b6dc66ba98\n **/","function label(contains) {\n    if(contains.length === 1) {\n        return String(contains[0]);\n    }\n\n    return `${contains[0]}-${contains[contains.length - 1]}`;\n}\n\n\nonmessage = function(e) {\n    let { TRIM, MAX_LENGTH, PEOPLE_IN_CAR, ITERATIONS, people, uniqueRides } = e.data;\n\n    let tmpFreqs = Array(Math.floor(people/PEOPLE_IN_CAR) + 1).fill().map(() => (0));\n\n    Array(ITERATIONS).fill().map(() => {\n        let draws = Array(people).fill().map(() => (Math.floor(Math.random()*uniqueRides) + 1));\n        let tmp = {};\n        let shared = 0;\n\n        draws.map((draw) => {\n            if(tmp[draw] === undefined) {\n                tmp[draw] = 1;\n            }\n            else {\n                tmp[draw]++;\n            }\n\n            if(tmp[draw] === PEOPLE_IN_CAR) {\n                shared++;\n                tmp[draw] = 0;\n            }\n        });\n\n        tmpFreqs[shared]++;\n    });\n\n    let frequencies = tmpFreqs.map((freq) => (freq / ITERATIONS));\n    let shiftStart = 0;\n    if(TRIM) {\n        const threshold = Math.max(...frequencies) / 50;\n        while(frequencies[shiftStart] < threshold) {\n            shiftStart++;\n        }\n        frequencies.splice(0, shiftStart);\n\n        frequencies.reverse();\n\n        let cutEnd = 0;\n        while(frequencies[cutEnd] < threshold) {\n            cutEnd++;\n        }\n        frequencies.splice(0, cutEnd);\n\n        frequencies.reverse();\n    }\n\n    const centerGroupSize = Math.floor(frequencies.length / MAX_LENGTH) || 1;\n    const borderGroupSize = Math.ceil(frequencies.length / MAX_LENGTH);\n\n    let finalLength;\n    let centerGroupNumber;\n    let borderGroupNumber;\n    if(frequencies.length <= MAX_LENGTH) {\n        finalLength = frequencies.length;\n        centerGroupNumber = frequencies.length;\n        borderGroupNumber = 0;\n    }\n    else {\n        finalLength = MAX_LENGTH;\n        centerGroupNumber = MAX_LENGTH - (frequencies.length % MAX_LENGTH);\n        borderGroupNumber = MAX_LENGTH - centerGroupNumber;\n    }\n\n    let borderGroupBeforeCenter = Math.ceil(borderGroupNumber / 2);\n\n    let workedFrequencies = Array(finalLength).fill();\n    frequencies.map((freq, i) => {\n        let newIndex;\n        if(i < (borderGroupBeforeCenter*borderGroupSize)) {\n            newIndex = Math.floor(i / borderGroupSize);\n        }\n        else if(i >= (borderGroupBeforeCenter*borderGroupSize + centerGroupNumber*centerGroupSize)) {\n            let fakeI = i - (borderGroupBeforeCenter*borderGroupSize + centerGroupNumber*centerGroupSize);\n            newIndex = borderGroupBeforeCenter + centerGroupNumber + Math.floor(fakeI / borderGroupSize);\n        }\n        else {\n            let fakeI = i - borderGroupBeforeCenter*borderGroupSize;\n            newIndex = borderGroupBeforeCenter + Math.floor(fakeI / centerGroupSize);\n        }\n\n        if(workedFrequencies[newIndex] === undefined) {\n            workedFrequencies[newIndex] = {\n                freq: 0,\n                contains: []\n            }\n        }\n\n        workedFrequencies[newIndex].freq += freq;\n        workedFrequencies[newIndex].contains.push(i+shiftStart);\n    });\n\n    const formattedFrequencies = workedFrequencies.map((wf) => ({label: label(wf.contains), freq: wf.freq}));\n    postMessage({ formattedFrequencies});\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./worker.js\n **/"],"sourceRoot":""}